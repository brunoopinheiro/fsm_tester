from unittest.runner import TextTestRunner
from unittest.case import TestCase
from unittest.suite import TestSuite
from src.adapters import (
    AdapterFactory,
)
from src.entities import FSMProtocol
from src.components.graph_analyzer import GraphAnalyzer
from src.components.machine_mocker import MachineMocker
from src.typing import DIALECTS


class FSMTester():

    test_suites = [
        'unreachable_states_suite',
        'sink_states_suite',
        'nondeterministic_transition_suite',
        'machine_execution_suite',
        'deadlock_states_suite',
    ]

    def __init__(
        self,
        fsm_module: FSMProtocol,
        final_state: str,
        dialect: DIALECTS = 'pytransitions',
        expected_loops: int = 0,
        verbosity=2,
        *args,
        **kwargs,
    ) -> None:
        self.adapter = AdapterFactory.create_adapter(fsm_module, dialect)
        self.final_state = final_state
        self.graph = self.adapter.get_graph()
        self.test_runner = TextTestRunner(
            verbosity=verbosity,
        )
        self.graph_analyzer = GraphAnalyzer(
            graph=self.graph,
            initial_state=self.adapter.initial_state,
            final_state=self.final_state,
        )
        self.machine_mocker = MachineMocker(
            adapter=self.adapter,
            expected_loops=expected_loops,
            final_state=final_state,
        )
        self.suites = list()
        self.suites.append(self.graph_analyzer.unreachable_states_suite())
        self.suites.append(self.graph_analyzer.sink_states_suite())
        self.suites.append(
            self.graph_analyzer.nondeterministic_transition_suite(
                transitions=self.adapter.get_transitions(),
            )
        )
        # maybe this part should be executed only if the graph tests pass
        self.suites.append(
            self.machine_mocker.unreachable_states_suite(),
        )
        self.exit = True

    @property
    def unreachable_states_suite(self) -> TestSuite:
        return self.graph_analyzer.unreachable_states_suite()

    @property
    def sink_states_suite(self) -> TestSuite:
        return self.graph_analyzer.sink_states_suite()

    @property
    def nondeterministic_transition_suite(self) -> TestSuite:
        return self.graph_analyzer.nondeterministic_transition_suite(
            transitions=self.adapter.get_transitions(),
        )

    @property
    def machine_execution_suite(self) -> TestSuite:
        return self.machine_mocker.unreachable_states_suite()

    @property
    def deadlock_states_suite(self) -> TestSuite:
        return self.machine_mocker.dead_lock_suite()

    def __getitem__(self, name):
        if name in FSMTester.test_suites:
            return super(FSMTester, self).__getattribute__(name)
        raise KeyError(f'{name} is not a valid test suite.')

    @staticmethod
    def _report_errors(fail_msg_base: str, failure_results: list) -> str:
        summary_info = f'[{fail_msg_base}]: '
        for failure in failure_results:
            summary_info += str(failure)
        return summary_info

    def run(self, test_suite: TestSuite):
        """Runs a test suite.

        Args:
            test_suite (TestSuite): A test suite to be run.
        """
        suite_results = list()
        failures = list()
        for test in test_suite:
            test: TestCase
            self.test = test
            result = self.test_runner.run(test)
            is_successful = result.wasSuccessful()
            if not is_successful:
                failures.append(test)
            suite_results.append(is_successful)
        errors_report = self._report_errors(test_suite.fail_msg, failures)
        assert all(suite_results), errors_report

    def run_tests(self):
        """Run all the test suites generated by the FSMTester."""
        # TODO: Differentiate the result report for each suite.
        for suite in self.suites:
            suite_results = list()
            failures = list()
            for test in suite:
                test: TestCase
                self.test = test
                result = self.test_runner.run(test)
                is_successful = result.wasSuccessful()
                if not is_successful:
                    failures.append(test)
                suite_results.append(is_successful)
            errors_report = self._report_errors(suite.fail_msg, failures)
            assert all(suite_results), errors_report
